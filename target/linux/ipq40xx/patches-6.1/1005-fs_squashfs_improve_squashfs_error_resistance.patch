From: Oever González <notengobattery@gmail.com>
Subject: [PATCH] fs: SQUASHFS: improve SQUASHFS error resistance
Date: Sat, 25 Jul 2020 18:49:31 -0600

This patch greatly improves the SQUASHFS's ability to deal with read errors. By
applying this patch, a corrupted page in the cache will not longer lead to a
persistent failure in decompression, at least most of the times.

Signed-off-by: Oever González <notengobattery@gmail.com>

--- a/fs/squashfs/block.c
+++ a/fs/squashfs/block.c
@@ -137,7 +137,7 @@ out_free_bio:
  * generated a larger block - this does occasionally happen with compression
  * algorithms).
  */
-int squashfs_read_data(struct super_block *sb, u64 index, int length,
+static inline int __squashfs_read_data(struct super_block *sb, u64 index, int length,
 		       u64 *next_index, struct squashfs_page_actor *output)
 {
 	struct squashfs_sb_info *msblk = sb->s_fs_info;
@@ -226,11 +226,46 @@ out_free_bio:
 	bio_uninit(bio);
 	kfree(bio);
 out:
-	if (res < 0) {
-		ERROR("Failed to read block 0x%llx: %d\n", index, res);
-		if (msblk->panic_on_errors)
-			panic("squashfs read failed");
+	return res;
+}
+
+/*
+ * If some kind of error is detected, block into this loop rather than crashing
+ * the process that requested the data, since it can be `init` and crashing it
+ * will lead to a kernel panic. If the read still failing, the process is doomed
+ * to crash anyway.
+ *
+ * This only makes SQUASHFS more error resistant by avoiding the poisoning of
+ * the "front" cache if the first attempt failed.
+ *
+ */
+int squashfs_read_data(struct super_block *sb, u64 index, int length,
+		u64 *next_index, struct squashfs_page_actor *output)
+{
+	int ret = 0, attempts = 0;
+	unsigned long long block = (unsigned long long) index;
+	u64 saved_next_index;
+
+	if (next_index)
+		saved_next_index = *next_index;
+
+	ret = __squashfs_read_data(sb, index, length, next_index, output);
+
+	while (ret < 0 && attempts < 5) {  // Retry 5 times, a total of 6 attempts
+		attempts++;
+		TRACE("failed to read block [%llx], retry attempt %d\n",
+			block, attempts);
+		if (next_index)
+			*next_index = saved_next_index;
+		ret = __squashfs_read_data(sb, index, length, next_index, output);
 	}
 
-	return res;
+	if (attempts > 0 && ret >= 0)
+		TRACE("read_data: success after %d attempts to read block [%llx]\n",
+			attempts, block);
+	else if (attempts > 0 && ret < 0)
+		ERROR("read_data: failed after %d attempts to read block [%llx]\n",
+			attempts + 1, block);
+
+	return ret;
 }
--- a/fs/squashfs/cache.c
+++ a/fs/squashfs/cache.c
@@ -112,8 +112,12 @@ struct squashfs_cache_entry *squashfs_ca
 
 			spin_lock(&cache->lock);
 
-			if (entry->length < 0)
+			if (entry->length < 0) {
 				entry->error = entry->length;
+				WARNING("Invalidated %s cache entry [%llx]\n", cache->name,
+					entry->block);
+				entry->block = SQUASHFS_INVALID_BLK;
+			}
 
 			entry->pending = 0;
 
--- a/fs/squashfs/decompressor_multi.c
+++ a/fs/squashfs/decompressor_multi.c
@@ -190,8 +190,6 @@ int squashfs_decompress(struct squashfs_
 	res = msblk->decompressor->decompress(msblk, decomp_stream->stream,
 		bio, offset, length, output);
 	put_decomp_stream(decomp_stream, stream);
-	if (res < 0)
-		ERROR("%s decompression failed, data probably corrupt\n",
-			msblk->decompressor->name);
+
 	return res;
 }
--- a/fs/squashfs/decompressor_multi_percpu.c
+++ a/fs/squashfs/decompressor_multi_percpu.c
@@ -89,10 +89,6 @@ int squashfs_decompress(struct squashfs_
 
 	local_unlock(&msblk->stream->lock);
 
-	if (res < 0)
-		ERROR("%s decompression failed, data probably corrupt\n",
-			msblk->decompressor->name);
-
 	return res;
 }
 
--- a/fs/squashfs/decompressor_single.c
+++ a/fs/squashfs/decompressor_single.c
@@ -71,10 +71,6 @@ int squashfs_decompress(struct squashfs_
 		offset, length, output);
 	mutex_unlock(&stream->mutex);
 
-	if (res < 0)
-		ERROR("%s decompression failed, data probably corrupt\n",
-			msblk->decompressor->name);
-
 	return res;
 }
 
--- a/fs/squashfs/super.c
+++ a/fs/squashfs/super.c
@@ -535,7 +535,7 @@ static int __init init_squashfs_fs(void)
 		return err;
 	}
 
-	pr_info("version 4.0 (2009/01/31) Phillip Lougher\n");
+	pr_info("patched 4.0 (2024/04/15) r3d5ky\n");
 
 	return 0;
 }
